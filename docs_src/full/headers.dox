/**
  @file src/quadratic_equation.h
  @brief Заголовочный файл модуля Quadratic Equation.

  @details
  Содержит описание для функций для решения квадратного уравнения. Включает,
  описание необходимых типов и структур. В дополнение содержит макрос 
  "перегружающий" вызов этих функций.
 */
/**
  @file src/quadratic_equation.c
  @brief 
  Исходный файл модуля квадратных уравнений. Содержит реализацию функций the @ref solve_equation 
  и @ref solve_equation_accur functions.
 */
/**
  @file src/helpers/quadeq_helpers.h
  @brief 
  Заголовочный файл вспомогательных элементов, используемых в функции @ref solve_equation_accur
 */
/**
  @file src/helpers/quadeq_helpers.c
  @brief 
  Исходный файл вспомогательных функций используемых в функции @ref solve_equation_accur
 */

/**
  @defgroup quadratic_equation Quadratic Equation
  @brief Модуль для решения квадратного уравнения
 */
///@{
/** 
  @typedef EquationResult
  @brief
  Множество возможных решений квадратного уравнения. Используется в структуре EquationRoots.
  @details
  Определяет количество и тип корней квадратного уравнения.
  Стоит отдельно пояснить случай, когда уравнение имеет один действительный корень. Это может произойти:
  - Когда дискриминант уравнения равен нулю.
  - Когда a=0, т.е. когда уравнение вырождается в линейное.
  В определенных математических контекстах первый случай рассматривается как эквивалентный 
  двум одинаковым корням, тогда как второй всегда рассматривается только как один корень.
  Может быть важно различать эти сценарии, поэтому значения @ref OneDoubleRoot и @ref OnlyOneRoot используются 
  соответственно для этих двух случаев.
 */
/**
  @var NoRoots
  @brief Отсутствие корней
  @details
  - Этот случай реализуется для уравнений типа \f$0x^2 + 0x + c = 0\f$
  при \f$c \ne 0\f$.
  - Реальная часть обоих возвращаемых корней равна NAN.
  - Дискриминант не вычисляется.
 */
/**
  @var OneDoubleRoot
  @brief Уравнение имеет два одинаковых корня (один сдвоенный).
  @details
  - Этот случай возникает, когда дискриминант уравнения равен нулю.
  - В этом случае возвращаются 2 одинаковых действительных корня с нулевой мнимой частью.
 */
/**
  @var OnlyOneRoot
  @brief Уравнение имеет ровно один корень.
  @details
  - Этот случай реализуется для уравнений типа \f$0x^2 + bx + c = 0\f$
  при \f$b \ne 0\f$.
  - В этом случае первый корень имеет нулевую мнимую часть, а второй имеет реальную часть равную NAN.
  - Дискриминант не вычисляется.
  - Корень вычисляется по формуле \f$-\frac{c}{b}\f$
 */
/**
  @var TwoRealRoots
  @brief Уравнение имеет два действительных корня.
  @details
  - Этот случай возникает, когда дискриминант уравнения положительный.
  - В этом случае мнимая часть у обоих корней равна нулю.
 */
/**
  @var TwoComplexRoots
  @brief Уравнение имеет два комплексных корня.
  @details
  - Этот случай возникает, когда дискриминант уравнения отрицательный.
  - В этом случае у обоих корней мнимая часть ненулевая.
 */
/**
  @var InfinityRoots
  @brief Решением уравнения является любое число.
  @details
  - Этот случай реализуется для уравнений типа \f$0x^2 + 0x + 0 = 0\f$.
  - Реальная часть обоих возвращаемых корней равна NAN.
  - Дискриминант не вычисляется.
 */
/**
  @var InvalidValue
  @brief Это уравнение неверно.
  @details
  Это возможно в двух случаях:
  - Хотя бы один из аргументов a, b, c равен бесконечности или NAN.
  - Недопустимый аргумент accuracy, если дискриминант вычисляется.

  В любом случае реальная часть обоих возвращаемых корней равна NAN.
 */

/**
  @struct EquationRoots
  @brief
  Структура возвращаемого значения функций @ref solve_equation и @ref solve_equation_accur.
  @details
  Содержит значение одного из случаев решения квадратного уравнения и два комплексных корня.
  - Если rootsNumber равен @ref NoRoots, @ref InfinityRoots или @ref InvalidValue, то реальная часть обоих 
  возвращаемых корней равна NAN.
  - Если rootsNumber равен @ref OnlyOneRoot
    - Реальная часть первого корня является конечным числом, а мнимая часть равна 0.
    - Реальная часть второго корня равна NAN.
  - В остальных случаях реальная и мнимая часть обоих возвращаемых корней не равна NAN. И
    - Если rootsNumber равен @ref OneDoubleRoot, действительные части корней равны друг другу, 
    и мнимые части равны 0.
    - Если rootsNumber равен @ref TwoRealRoots, действительная часть первого корня меньше, чем действительная часть второго,
    и мнимые части равны 0.
    - Если rootsNumber равен @ref TwoComplexRoots, действительные части корней равны друг другу,
    и мнимая часть первого корня отрицательная, а второго - положительная и равны друг другу по абсолютному значению.
 */
/**
  @var EquationRoots::rootsNumber
  @brief
  Количество и тип корней квадратного уравнения.
  @details
  Подробнее см. @ref EquationResult.
 */
/**
  @var EquationRoots::root1
  @brief
  Первый комплексный корень
  @details
  Действительная часть не больше, чем у root2, а мнимая часть не положительная.
 */
/**
  @var EquationRoots::root2
  @brief
  Второй комплексный корень
  @details
  Действительная часть не меньше, чем у root1, а мнимая часть не отрицательная.
 */

/**
  @fn EquationRoots solve_equation(long double a, long double b, long double c);
  @brief 
  Функция для решения квадратного уравнения с точностью по умолчанию (@ref accur_default_sec) 
  вычисления дискриминанта.
  @param a,b,c - коэффициенты уравнения \f$ax^2 + bx + c =  0\f$.
  @return Структура с возможными решениями уравнения и двумя
  комплексными корнями (см. @ref EquationRoots).
 */


/**
  @fn EquationRoots solve_equation_accur(long double a, long double b, long double c, const char *accuracy);
  @brief 
  Функция для решения квадратного уравнения с заданной точностью вычисления 
  дискриминанта.
  @param a,b,c - коэффициенты уравнения \f$ax^2 + bx + c = 0\f$.
  @param accuracy - строка использовемой точности вычисления дискриминанта.
  Подробнее см. @ref accuracy.
  @return Структура с возможными решениями уравнения и двумя
  комплексными корнями (см. @ref EquationRoots).
 */


/**
  @def GET_FUNCTION
  @brief 
  Вспомогательный макрос для SOLVE_EQUATION(...).
  @details
  Подсчитывает количество переданных параметров (до 4) 
  и возвращает значение из набора под этим номером. Номера 
  в наборе следуют в обратном порядке.
 */

/**
  @def SOLVE_EQUATION
  @brief
  Макрос перегружающий вызов функций @ref solve_equation and @ref solve_equation_accur.
  
  @details
  Если передается три аргумента, то вызывается функция @ref solve_equation.
  Если передается четыре аргумента, то вызывается функция @ref solve_equation_accur.
 */

///@}

/**
 * @defgroup helpers_module Quadratic Equation Helpers
 * @ingroup quadratic_equation
 *   @brief Подмодуль вспомогательных функций для Quadratic Equation
 */
///@{

/**
  @def ABSOLUTE_VALUE
  @brief 
  Макрос для вычисления абсолютного значения.
  @details
  Можно заменить на библиотечный fabsl(). Но макрос нравится больше.
 */
/**
  @def MINIMUM
  @brief 
  Макрос для определения минимального из двух чисел.
 */
/**
  @def SAME_SIGN
  @brief 
  Макрос определяющий одинаковые ли знаки двух ненулевых чисел.
  @details
  Важно, что это макрос корректно работает только для ненулевых чисел. В данном модуле
  этот макрос применяется только для ненулевых чисел.
 */
/**
  @def DISCRIMINANT_EPSILON
  @brief 
  Макрос считает наименьшее по абсолютной величине значение дискриминанта, которое будет считаться 
  отличным от нуля по заданной абсолютной точности.
  @details
  Абсолютная точность (@ref accur_absolute_sec) для неотрицательных значений - это наибольшее количество 
  знаков после запятой в десятичной записи среди коэффициентов a, b, c квадратного уравнения \f$ax^2 + bx + c = 0\f$.
  Поэтому количество знаков после запятой для дискриминанта \f$D = b^2 - 4ac\f$ не превышает удвоенного значения
  абсолютной точности. Поэтому значения дискриминанта по абсолютной величине меньшие \f$10^{-2\cdot ten\_power}\f$ 
  (ten_power - значение абсолютной точности) можно считать равными нулю.
  Для отрицательных значений абсолютной точности (количество нулей перед запятой) рассуждения аналогичны и приводят 
  к такому же результату.
  Макрос вычисляет это критическое значение по заданной абсолютной точности.
 */
/**
  @def SQRT_DISCRIMINANT_EPSILON
  @brief 
  Макрос считает наименьшее по абсолютной величине значение корня из дискриминанта, которое будет считаться 
  отличным от нуля по заданной абсолютной точности.
  @details
  Рассуждения аналогичны @ref DISCRIMINANT_EPSILON, поэтому для корня из дискриминанта нужно проводить сравнение
  с \f$10^{-ten\_power}\f$. Макрос вычисляет это критическое значение по заданной абсолютной точности.
 */

/** 
  @typedef EquationCases
  @brief
  Множество возможных комбинаций входных аргументов a, b, c.
 */
 /**
  @var ERROR_INPUT
  @brief
  Хотя бы один из аргументов a, b, c не является конечным числом.
  @details
  В этом случае решить уравнение не возможно. Будет выдана сообщение об ошибке.
*/
/**
  @var USUAL
  @brief
  Обычный случай, когда все аргументы a, b, c являются конечными ненулевыми числами.
  @details
  Обычный случай, когда для решения квадратного уравнения будет рассчитан дискриминант.
*/
/**
  @var ZERO_ABC
  @brief
  Случай, когда \f$a = 0, b = 0, c = 0\f$.
  @details
  В таком случае уравнение вырождается в \f$0x^2 + 0x + c = 0\f$, решение которого - любое число.
*/
/**
  @var ZERO_AB
  @brief
  Случай, когда \f$a = 0, b = 0, c \neq 0\f$.
  @details
  В таком случае уравнение вырождается в \f$0x^2 + 0x + c = 0\f$, у которого нет решения при ненулевом c.
*/
/**
  @var ZERO_BC
  @brief
  Случай, когда \f$a \neq 0, b = 0, c = 0\f$.
  @details
  В таком случае уравнение вырождается в \f$ax^2 = 0\f$, решение которого \f$x = 0\f$. При этом считается, что 
  это два одинаковых корня.
*/
/**
  @var ZERO_A
  @brief
  Случай, когда \f$a = 0, b \neq 0\f$, а значение параметра c любое конечное число.
  @details
  В таком случае уравнение вырождается в линейное уравнение \f$bx + c = 0\f$, решение которого \f$x = -\frac cb\f$.
  При этом считается, что это один корень.
*/
/**
  @var ZERO_B
  @brief
  Случай, когда \f$a \neq 0, b = 0, c \neq 0\f$.
  @details
  В таком случае уравнение вырождается в неполное квадратное уравнение \f$ax^2 + c = 0\f$, 
  которое можно решить без использования дискриминанта. Получается \f$x = -\frac ca\f$, и в зависимости от знака 
  выражения \f$-\frac ca\f$ может быть, либо два действительных корня \f$x_{1,2} = \pm\sqrt{-\frac ca}\f$ (для положительных),
  либо два комплексных корня \f$x_{1,2} =\pm i\sqrt{\frac ca}\f$ (для отрицательных). Равняться нулю это выражение не может, 
  т.к. это случай ZERO_BC.
*/
/**
  @var ZERO_C
  @brief
  Случай, когда \f$a \neq 0, b \neq 0, c = 0\f$.
  @details
  В таком случае уравнение вырождается в неполное квадратное уравнение \f$ax^2 + bx = 0\f$, решение которого 
  два действительных корня, один из которых всегда 0, а второй равен \f$x = -\frac ba\f$.
*/


/** 
  @typedef PrecisionType
  @brief 
  Множество используемых типов точности.
*/
/**
  @var NUMBER_PRECISION
  @brief
  Абсолютная точность. Задано количество цифр после запятой.
*/
/**
  @var TYPE_PRECISION
  @brief
  Относительная точность. Задан тип входных аргументов.
*/

/**
  @struct Accuracy
  @brief 
  Структура хранящая точность сравнения дискриминанта с нулем.
  @details
  Если задается абсолютна точность, то PrecisionType = NUMBER_PRECISION, и значение точности 
  хранится в поле value.precision. Если задается относительная точность, то PrecisionType = TYPE_PRECISION,
  и значение точности хранится в поле value.type.
  Отдельный момент, про относительную точность заданную через "i" или "I". Она записывается 
  PrecisionType = NUMBER_PRECISION и value.ten_power = 0.
  Про точность можно прочитать подробнее в @ref accuracy.
*/
/**
  @var Accuracy::type
  @brief
  Определяет какой тип точности используется: абсолютная или относительная.
*/
/**
  @var Accuracy::value
  @brief
  Объединение хранящее значение точности либо числом, либо символом.
*/

/**
 @fn EquationCases ascertain_equation_case(long double a, long double b, long double c);
 @brief 
 Функция определяющая возможные комбинации входных аргументов a, b, c.
 @param a,b,c - коэффициенты квадратного уравнения \f$ax^2 + bx + c = 0\f$.
 @return
 Одно из значений множества возможных комбинаций входных аргументов a, b, c (см. @ref EquationCases).
 */

/**
 @fn int check_accuracy(const char *accuracy, Accuracy *epsilon);
 @brief 
 Парсит входную строку accuracy и конвертирует ее в структуру Accuracy.
 @param[in] accuracy - строка точности сравнения дискриминанта с нулем.
 @param[out] epsilon - возвращает структуру Accuracy, хранящую значение точности.
 @return 0, если строка корректна, 1 в противном случае.
 */

/**
 @fn long double count_sqrt_discriminant(long double a, long double b, long double c, Accuracy epsilon);
 @brief
 Считает корень из дискриминанта уравнения \f$ax^2 + bx + c = 0\f$ с конечными ненулевыми коэффициентами, 
 с заданной точностью сравнения дискриминанта с нулем.
 @warning
 Для отрицательного дискриминанта \f$D\f$ функция возвращает действительное значение \f$-\sqrt{-D}\f$. 
 Это удобная условность: знак дискриминанта по прежнему известен, но работа с комплексными значениями 
 переносится в функцию solve_equation_accur. 
 @param a,b,c - коэффициенты квадратного уравнения \f$ax^2 + bx + c = 0\f$.
 @param epsilon - Точность сравнения дискриминанта с нулем.
 @return  Значение корня из дискриминанта.
 @details
 Считает корень из дискриминанта \f$D = b^2 - 4ac\f$. По значению точности вычисляется граничное значение,
 и происходит проверка значения дискриминанта: дискриминант меньший этого граничного значения, будет приравнен к нулю.
 Для нулевого дискриминанта функция возвращает нуль. Для положительного - возвращает \f$\sqrt{D}\f$, 
 а для отрицательного - \f$-\sqrt{-D}\f$.
 В функции есть отдельный блок работы с очень большими числами, такими, что прямое вычисление дискриминанта приводит 
 к бесконечности. Подробнее см. @ref code_detailed_solve_equation_accur.
 */

/**
 @fn long double sqrt_number_with_type_precision(long double number, long double benchmark, char type_precision);
 @brief 
 Считает корень числа, с заданной относительной точностью сравнения с нулем.
 @param number - число, корень из которого нужно извлечь.
 @param benchmark - число, относительно которого будет производиться сравнение с нулем.
 @param type_precision - символ типа точности.
 @return  Значения корня числа
 @warning В этом проекте значение benchmark не может быть равно нулю. Поэтому в функции нет проверки 
 значения benchmark на ноль. Если в последующих версиях проекта в функцию @ref count_sqrt_discriminant
 смогут попадать ноль хотя бы в одном аргументе (а, b, c), то нужно добавить такую проверку.
 @details
 Сравнивает значение \f$\left|\frac{number}{benchmark}\right|\f$ с машинным эпсилоном (FLT_EPSILON, DBL_EPSILON 
 и LDBL_EPSILON в зависимости от type_precision). Если оно меньше, то возвращает 0, иначе возвращает \f$\sqrt{number}\f$ 
 для положительного number, и \f$-\sqrt{-number}\f$ - для отрицательного.
 Это работает потому, что  в качестве benchmark подается наименьшее по абсолютному значению из чисел 
 \f$ b^2\f$ и \f$4ac\f$, а в качестве number значение дискриминанта, т.е.  \f$ b^2 - 4ac\f$. Поэтому с машинным
 эпсилоном сравнивается \f$\left|\frac{b^2}{4ac} - 1\right|\f$ или \f$\left|1 - \frac{4ac}{b^2}\right|\f$.
 Согласно определению, машинный эпсилон это "разница между 1 и минимальным значением, большим единицы,
 которое может быть представлено указанным типом данных". 
 Именно поэтому значения \f$\left|\frac{number}{benchmark}\right|\f$ меньшие машинного эпсилона приводят 
 к нулевому дискриминанту.
 */

///@}