/** 
  @page code_explanation Объяснение кода

  @section code_main_points Основные моменты
  Работа большинства функций в данном проекте достаточна проста, поэтому достаточно краткого описания. 
  Но некоторые их части будут разобраны @ref code_detailed.

  @subsection code_solve_equation Функция solve_equation
  @code
  EquationRoots solve_equation(long double a, long double b, long double c);
  @endcode
  Просто вызывает solve_equation_accur(a, b, c, NULL); Значение точности равное NULL соответствует 
  значению точности по умолчанию (см. @ref accur_default_sec).
  @snippet src/quadratic_equation.c solve_equation body

  @subsection code_solve_equation_accur Функция solve_equation_accur
  @code
  EquationRoots solve_equation_accur(long double a, long double b, long double c, Accuracy accuracy);
  @endcode
  Вначале инициализируются переменные:
  @snippet src/quadratic_equation.c initializing variables in solve_equation_accur
  - roots (тип EquationRoots) - возвращаемое значение функции. Первоначально инициализируется ошибкой InvalidValue.
  - sqrt_discriminant (тип long double) - корень из дискриминанта, если он вычисляется.
  - result (тип long double) - используется для вычисления корней не через дискриминант (это почти ответ).
  - epsilon (тип Accuracy) - точность вычислений. Первоначально инициализируется наибольшим значением 
  относительной точности "l".

  Затем вызывается функция ascertain_equation_case, значение которой сразу попадает в switch.
  @snippet src/quadratic_equation.c solve_equation_accur switch
  Чаще всего будет выбираться случай @ref USUAL, работа которого описана в @ref code_detailed_solve_equation_accur.
  Остальные случаи, возникают, когда один из коэффициентов a, b или c равен нулю. Тогда возможно решить уравнение
  без использования дискриминанта. Эти решения описаны в @ref EquationCases, и они просто реализованы и записаны в roots.
  @snippet src/quadratic_equation.c solve_equation_accur other cases
  Случай default соответствует случаю @ref ERROR_INPUT, ничего не происходит, поэтому в этом случае вернется ошибка 
  @ref InvalidValue.
  @snippet src/quadratic_equation.c solve_equation_accur default

  @subsection code_check_accuracy Функция check_accuracy
  @code
  int check_accuracy(const char *accuracy, Accuracy *epsilon);
  @endcode
  @ref accur_default_sec задается значениям NULL или пустой строкой. Оно принято за 
  значение относительной точности равное "l", поэтому первой строкой происходит одновременная проверка этих случаев.
  // @snippet src/helpers/quadeq_helpers.c check_accuracy first if
  Значения относительной точности проверяется только по первому символу строки accuracy. Поэтому вначале проверяется 
  именно возможные значения относительной точности. В случае совпадения символов с одним из значений, перечисленных
  в @ref accur_relative_sec, остальные символы строки не проверяются, записывается соответсвующее значение точности 
  в epsilon и функция завершается с кодом 0. При этом учитывается, что значения "i" и "I" на самом деле кодируют не 
  относительную точность, а абсолютную точность со значением 0.
  // @snippet src/helpers/quadeq_helpers.c check_accuracy relative accuracy
  Далее проверяется значение абсолютной точности. Можно было бы воспользоваться функцией atoi, но все равно пришлось
  бы отдельно обрабатывать вариант со значение 0 - это ошибка или действительно в строке 0. Поэтому было принято
  решение реализовать эту функцию самостоятельно, тем более, что значение абсолютной точности не может быть слишком 
  большим и можно прервать парсинг раньше. Подробнее о этой реализации см. @ref code_detailed_check_accuracy.

  Если же значения абсолютной точности не существует, то функция возвращает ошибку с кодом 1.
  @snippet src/helpers/quadeq_helpers.c check_accuracy end

  @subsection code_ascertain_equation_case Функция ascertain_equation_case
  @code
  EquationCase ascertain_equation_case(long double a, long double b, long double c);
  @endcode
  Вначале проверяется, что коэффициенты a, b и c являются конечными числами (т.е. ни одно из них не равно NAN, 
  INFINITY или -INFINITY), в противном случае возвращается ERROR_INPUT. 
  @snippet src/helpers/quadeq_helpers.c ascertain_equation_case first if
  Затем проверяется, равен ли нулю хоть  какой-нибудь коэффициент. Если это так, то выясняется какие именно 
  коэффициенты равны 0 и возвращается один из случаев в соотвествии с @ref EquationCases. Иначе возвращается
  случай USUAL.
  @snippet src/helpers/quadeq_helpers.c ascertain_equation_case zero case

  @subsection code_count_sqrt_discriminant Функция count_sqrt_discriminant
  @code
  long double count_sqrt_discriminant(long double a, long double b, long double c, Accuracy epsilon);
  @endcode
  @warning
  В этой функции ни одно из чисел a, b и c не может быть равно 0, т.к. эта функция вызывается в случае USUAL.

  Вначале проверяется epsilon на значение "z". Если это так, то это означает, что нужно в любом случае
  принять дискриминант равный 0 (см. @ref accur_relative_sec). В этом случае функция сразу возвращает 0.
  @snippet src/helpers/quadeq_helpers.c check z

  Далее инициализируются переменные \f$ bb = b^2 \f$, \f$ ac4 = 4 \cdot a \cdot c \f$ и  \f$ abs\_ac4 = |ac4| \f$. А также 
  discriminant (это дискриминант) и result (его вернет функция).
  @snippet src/helpers/quadeq_helpers.c count_sqrt_discriminant initializing variables

  Затем делается проверка, что обе переменные bb и ac4 конечные (т.е. не равны NAN, INFINITY или -INFINITY) и хотя 
  бы одно из них нормализованное (т.е. больше LDBL_MIN). Если одно из чисел нормализованное, а другое денормализованное, 
  то это нормальный случай, т.к. точности денормализованого числа хватит, чтобы вычислить дискриминант без потери 
  точности.
  @snippet src/helpers/quadeq_helpers.c check big and small
  Если проверка пройдена, то вычисляется дискриминант и проверяется тип точности в переменной epsilon. Если тип 
  точности TYPE_PRECISION, то в result записывается значение функции sqrt_number_with_type_precision. Иначе 
  (тип точности NUMBER_PRECISION) значение дискриминанта сравнивается с DISCRIMINANT_EPSILON и затем записывается 
  в result.
  @snippet src/helpers/quadeq_helpers.c standart count sqrt discriminant
  Если проверка не пройдена, то это ситуация или с очень большими, или с очень малыми числами. Подробнее о 
  работе с ними см. @ref code_detailed_sqrt_discriminant.

  @subsection code_sqrt_number_with_type_precision Функция sqrt_number_with_type_precision
  @code
  long double sqrt_number_with_type_precision(long double number, long double benchmark, char type_precision);
  @endcode
  В работе программы гарантируется, что benchmark не равен нулю. Поэтому без всяких проверок вычисляется 
  переменная precision, равная \f$ \left| \frac{number}{benchmark} \right| \f$. 
  @snippet src/helpers/quadeq_helpers.c initializing variables in sqrt_number_with_type_precision
  Это значение сравнивается с машинным эпсилоном, зависищим от type_precision 
  (см. @ref sqrt_number_with_type_precision).
  @snippet src/helpers/quadeq_helpers.c sqrt_number_with_type_precision switch
  Случай default в switch в реальности не используется, но покрывается в тестировании. Создан на всякий случай, 
  если программа в будущем будет работать с другими типами точности.
  @snippet src/helpers/quadeq_helpers.c sqrt_number_with_type_precision default

  @section code_detailed Более детально


  @subsection code_detailed_solve_equation_accur Подробнее о случае USUAL функции solve_equation_accur


  Случай USUAL означает, что все коэффициент a, b и c конечные и не равны нулю. В этом случае нужно вычислить
  дискриминант. Сразу вызывается функция check_accuracy, которая проверяет строку accuracy и в случае, если она 
  невалидна сразу возвращает исходные значения root (которые содержат ошибку). Иначе помещает распарсенное значение
  accuracy в переменную epsilon. И сразу вычисляется sqrt_discriminant c помощью функции count_sqrt_discriminant.
  @snippet src/quadratic_equation.c USUAL start
  Если значение sqrt_discriminant ноль, то это соответствует решению @ref OneDoubleRoot, и считаем значение roots по 
  формуле \f$x_{1,2} = \frac{-b}{2a}\f$.
  @snippet src/quadratic_equation.c zero discriminant
  А вот для ненулевого sqrt_discriminant может возникнуть случай, когда числитель в формуле корней уравнения 
  \f$x_{1,2} = \frac{-b \pm \sqrt{D}}{2a}\f$ станет бесконечным (для ужасающе огромных чисел). Поэтому делается 
  попытка разделить всё уравнение на \f$ 2a \f$, чтобы уменьшить коэффициенты. Это имеет смысл, если \f$ 2a>1 \f$ 
  (иначе они только увеличатся). 
  @snippet src/quadratic_equation.c check monster huge discriminant
  И опять вызывается функция count_sqrt_discriminant уже с новыми коэффициентами. 
  При этом нужно установить точность вычисления epsilon в значение "l", что соответствует наибольшей точности. 
  Это нужно чтобы из-за точности дискриминант случайно не занулился. Дело в том, что этот случай возможен только 
  при ненулевом дискриминанте, и при пропорциональном изменении всех коэффициентов должен остаться ненулевым.
  @snippet src/quadratic_equation.c one more attempt
  Если такое сокращение коэффициентов невозможно или всё равно будет давать бесконечность, то это судьба - значит 
  один из корней уравнения действительно по абсолютной величине больше LDBL_MAX. Поэтому никаких дополнительных 
  действий не делаем, просто досчитываем значения по формуле.

  Делаем проверку на знак sqrt_discriminant: положительный или отрицательный, что соответствует решениям 
  TwoRealRoots и TwoComplexRoots соответственно. Чтобы соблюсти порядок корней (@ref EquationRoots) нужно 
  учесть знак коэффициента a с помощью переменной sign_a. А в остальном просто считаем результат по формуле 
  и записываем его в roots.
  @snippet src/quadratic_equation.c standart solve equation

  @subsection code_detailed_sqrt_discriminant Подробнее работе с очень большими и малыми числами в sqrt_discriminant

  Чтобы объяснить как происходит работа с большими и малыми числами, необходимо вспомнить как устроен тип long double. 
  Один бит хранит знак числа, LDBL_MANT_DIG бит хранит мантиссу числа, а остальные хранят значение степени 2 
  (точнее FLT_RADIX, но для gcc это всегда 2). Основные проблемы с long double происходит из-за того, что при 
  умножении значение степени по абсолютной величине может увеличится и не хватит количества бит, выделенных для 
  ее хранения. 

  Поэтому основная идея - уменьшить значение степени (это не влияет на точность числа, т.к. точность хранится 
  в мантиссе), сделать необходимые вычисления и восстановить значение степени.

  Доступ к степени осуществляется с помощью стандартной функции ilogbl. Вводятся две новые переменные exp_ac4 и exp_bb, 
  которые представляют значение степени выражений \f$ 4ac \f$ и \f$ b^2\f$ соответственно. Т.к. Поскольку при умножении 
  степени складываются, то (помним, что \f$ 4=2^2 \f$)
  @snippet src/helpers/quadeq_helpers.c initializing variables exp_ac4 and exp_bb

  Далее можно проверить значения exp_ac4 и exp_bb. Если они отличаются более чем в LDBL_MANT_DIG, то значит при 
  вычислении дискриминанта одним числом можно пренебречь, т.к. даже самый старший бит мантиссы меньшего 
  числа будет меньше младшего бита большего числа. 

  Поэтому рассматривается два случая. Или exp_bb гораздо больше, тогда корень из дискриминанта будет 
  равен коэффициенту b. Нужно будет только проверить, что это значение не превышает абсолютную точность 
  (только теперь граничное значение точности считается с помощью макроса SQRT_DISCRIMINANT_EPSILON, т.к. 
  это уже извлеченный корень).
  @snippet src/helpers/quadeq_helpers.c bb more bigger case
  Если, наоборот, exp_ac4 больше, то корень из дискриминанта можно посчитать по формуле \f$ \pm2 \sqrt{|a|} \sqrt{|c|} \f$.
  Только нужно учесть знак: если знаки a и c одинаковые, то значение будет отрицательное, иначе положительное.
  Далее также идет проверка, что полученное значение не превышает абсолютную точность. 
  @snippet src/helpers/quadeq_helpers.c ac4 more bigger case
  Заметим, что в обоих рассмотренных случаях, не имеет смысл делать проверку на относительную точность - она точно 
  выполнится, т.к. её нужно делать относительно наименьшего числа, которым мы пренебрегаем.

  Если же пренебречь ни одним числом нельзя, то сдвигаем значение степени коэффициентов на величину:

  @snippet src/helpers/quadeq_helpers.c exponent shift

  Половина взялась оттого, что мы сдвигаем степень исходных коэффициентов, поэтому при умножении как раз выражение
  bb или ac4 с наименьшей степенью станет со степенью ноль, а степень наибольшего не превысит LDBL_MANT_DIG. Сдвиг 
  и восстановление степени осуществляется с помощью стандартной функции ldexpl.
  @snippet src/helpers/quadeq_helpers.c koefficients shift
  Далее вычисляем, как обычно, дискриминант. 
  @snippet src/helpers/quadeq_helpers.c another standart count sqrt discriminant
  И в конце, считаем корень из дискриминанта. Но есть отличие в порядке сравнения результата со значением 
  точности epsilon и восстановлением степени. Для относительной точности удобнее вначале 
  провести сравнение, т.к. она относительная и результат не зависит от конкретных значений, можно проводить его до 
  восстановления. а аргументы для sqrt_number_with_type_precision для восстановленных значений могут быть невалидны.
  @snippet src/helpers/quadeq_helpers.c check relative accuracy
  Для абсолютной точности, нужно вначале восстановить степень и потом проверить, что она не превышает точности.
  @snippet src/helpers/quadeq_helpers.c check absolute accuracy

  @subsection code_detailed_check_accuracy Подробнее парсинг числа в check_accuracy
  
  Парсинг строки accuracy в число достаточно стандартный.

  Вначале проверяется знак и сохраняется в переменную sign. Затем бежим в цикле по строке пока
  встречаются цифры, записывая результат в переменную ten_power. Переменная на каждой итерации 
  увеличивается в 10 раз и затем к ней прибавляется следующая цифра.
  @snippet src/helpers/quadeq_helpers.c parce circle
  Но есть нюанс. В цикле добавлено ещё условие ten_power < LDBL_MAX_10_EXP. LDBL_MAX_10_EXP -  это 
  максимальное целое значение для степени с основанием 10 в нормализованной форме представления числа long double.
  Поскольку абсолютная точность это количество знаков после запятой, то оно соотноситься со значением
  \f$10^{ -ten\_power}\f$. Поэтому значение ten_power по абсолютному значению должно не превышать LDBL_MAX_10_EXP.
  
  Поэтому после цикла сделана проверка, на превышение LDBL_MAX_10_EXP. Если превышает, то в зависимости от знака, 
  это означает или что это число превышает LDBL_MAX, а значит это эквивалентно заданию относительной точности 
  со значением "z", или что это число меньше LDBL_MIN, а значит это эквивалентно заданию относительной точности 
  со значением "l".
  @snippet src/helpers/quadeq_helpers.c check big accuracy

  Тут есть момент, что на самом деле значение \f$10^{LDBL\_MAX\_10\_EXP}\f$ ещё не равно INFINITY, да и число 
  \f$10^{ -LDBL\_MAX\_10\_EXP}\f$ еще не ноль, а всего лишь денормализованное число. Но ~~извращенцы которым
  понадобились такие значения точности - должны страдать~~ необходимость реализации таких ситуаций кажется 
  маловероятной, и ~~за большие деньги~~ при необходимости, может быть добавлена в следующих версиях проекта.

  Если полученное число не превышает LDBL_MAX_10_EXP, то просто записываем это значение в epsilon с учетом знака.
  @snippet src/helpers/quadeq_helpers.c save absolute accuracy
 */