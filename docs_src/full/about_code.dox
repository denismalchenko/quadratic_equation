/** 
  @page code_explanation Объяснение кода

  @section code_main_points Основные моменты
  Работа большинства функций в данном проекте достаточна проста, поэтому достаточно краткого описания. 
  Но некоторые их части будут разобраны @ref code_detailed.

  @subsection code_solve_equation Функция solve_equation
  @code
  EquationRoots solve_equation(long double a, long double b, long double c);
  @endcode
  Просто вызывает solve_equation_accur(a, b, c, NULL); Значение точности равное NULL соответствует 
  значению точности по умолчанию (см. @ref accur_default_sec).

  @subsection code_solve_equation_accur Функция solve_equation_accur
  @code
  EquationRoots solve_equation_accur(long double a, long double b, long double c, Accuracy accuracy);
  @endcode
  Вначале инициализируются переменные:
  - roots (тип EquationRoots) - возвращаемое значение функции. Первоначально инициализируется ошибкой InvalidValue.
  - sqrt_discriminant (тип long double) - корень из дискриминанта, если он вычисляется.
  - result (тип long double) - используется для вычисления корней не через дискриминант (это почти ответ).
  - epsilon (тип Accuracy) - точность вычислений (см. @ref Accuracy). Первоначально инициализируется наибольшим значением 
  относительной точности "l".

  Затем вызывается функция ascertain_equation_case, значение которой сразу попадает в switch.
  Чаще всего будет выбираться случай USUAL, работа которого описана в @ref code_detailed_solve_equation_accur.
  Остальные случаи, возникают, когда один из коэффициентов a, b или c равен нулю. Тогда возможно решить уравнение
  без использования дискриминанта. Эти решения описаны в @ref EquationCases, и они просто реализованы и записаны в roots.
  Случай default соответствует случаю ERROR_INPUT, ничего не происходит, поэтому в этом случае вернется ошибка InvalidValue.

  @subsection code_check_accuracy Функция check_accuracy
  @code
  int check_accuracy(const char *accuracy, Accuracy *epsilon);
  @endcode
  Точность по умолчанию (@ref accur_default_sec) задается значениям NULL или пустой строкой. Оно принято за 
  значение относительной точности равное "l", поэтому первой строкой и происходит одновременная проверка этих случаев.

  Значения относительной точности проверяется только по первому символу строки accuracy. Поэтому вначале проверяется 
  именно возможные значения относительной точности. В случае совпадения символов с одним из значений, перечисленных
  в @ref accur_relative_sec, остальные символы строки не проверяются, записывается соответсвующее значение точности 
  в epsilon и функция завершается с кодом 0. При этом учитывается, что значения "i" и "I" на самом деле кодируют не 
  относительную точность, а абсолютную точность со значением 0.

  Далее проверяется значение абсолютной точности. Можно было бы воспользоваться функцией atoi, но все равно пришлось
  бы отдельно обрабатывать вариант со значение 0 - это ошибка или действительно в строке 0. Поэтому было принято
  решение реализовать эту функцию самостоятельно, тем более, что значение абсолютной точности не может быть слишком 
  большим и можно прервать парсинг раньше. Подробнее о этой реализации см. @ref code_detailed_check_accuracy.

  Если же значения абсолютной точности не существует, то функция возвращает ошибку с кодом 1.

  @subsection code_ascertain_equation_case Функция ascertain_equation_case
  @code
  EquationCase ascertain_equation_case(long double a, long double b, long double c);
  @endcode
  Вначале проверяется, что коэффициенты a, b и c являются конечными числами (т.е. ни одно из них не равно NAN, 
  INFINITY или -INFINITY), в противном случае возвращается ERROR_INPUT. Затем проверяется, равен ли нулю хоть
  какой-нибудь коэффициент. Если это так, то выясняется какие именно коэффициенты равны 0 и
  возвращается один из случаев в соотвествии с @ref EquationCases. Иначе возвращается случай USUAL.


  @subsection code_count_sqrt_discriminant Функция count_sqrt_discriminant
  @code
  long double count_sqrt_discriminant(long double a, long double b, long double c, Accuracy epsilon);
  @endcode
  @warning
  В этой функции ни одно из чисел a, b и c не может быть равно 0, т.к. эта функция вызывается в случае USUAL.

  Вначале проверяется epsilon на значение "z". Если это так, то это означает, что нужно в любом случае
  принять дискриминант равный 0 (см. @ref accur_relative_sec). В этом случае функция сразу возвращает 0.

  Далее инициализируются переменные /f$ bb = b^2 /f$, /f$ ac4 = 4 * a * c /f$ и  /f$ abs_ac4 = |ac4| /f$. А также 
  discriminant (это дискриминант) и result (его вернет функция).

  Затем делается проверка, что обе переменные bb и ac4 конечные (т.е. не равны NAN, INFINITY или -INFINITY) и хотя 
  бы одно из них нормализованное (т.е. больше LDBL_MIN). Если одно из чисел нормализованное, а другое денормализованное, 
  то это нормальный случай, т.к. точности денормализованого числа хватит, чтобы вычислить дискриминант без потери 
  точности.

  Если проверка пройдена, то вычисляется дискриминант и проверяется тип точности в переменной epsilon. Если тип 
  точности TYPE_PRECISION, то в result записывается значение функции sqrt_number_with_type_precision. Иначе 
  (тип точности NUMBER_PRECISION) значение дискриминанта сравнивается с DISCRIMINANT_EPSILON и затем записывается 
  в result.

  ЕСли проверка не пройдена, то имеет дела работа или с очень большими или с очень малыми числами. Подробнее о 
  работе с ними см. @ref code_detailed_sqrt_discriminant.

  @subsection code_sqrt_number_with_type_precision Функция sqrt_number_with_type_precision
  @code
  long double sqrt_number_with_type_precision(long double number, long double benchmark, char type_precision);
  @endcode
  В работе программы гарантируется, что benchmark не равен нулю. Поэтому без всяких проверок вычисляется 
  переменная precision, равная /f$ \left| \frac{number}{benchmark} \right| /f$. Это значение сравнивается с машинным 
  эпсилоном, зависищим от type_precision (см. @ref sqrt_number_with_type_precision).
  Случай default в switch в реальности не используется, но покрывается в тестировании. Создан на всякий случай, 
  если программа в будущем будет работать с другими типами точностей.

  @section code_detailed Более детально
  @subsection code_detailed_solve_equation_accur Подробнее о случае USUAL функции solve_equation_accur
  Случай USUAL означает, что все коэффициент a, b и c конечные и не равны нулю. В этом случае нужно вычислить
  дискриминант. Сразу вызывается функция check_accuracy, которая проверяет строку accuracy и в случае если она 
  невалидна сразу возвращает исходные значения root (которые содержат ошибку). Иначе помещает распарсенное значение
  accuracy в переменную epsilon. И сразу вычисляется sqrt_discriminant c помощью функции count_sqrt_discriminant.

  И во здесь может возникнуть случай, когда числитель в формуле корней уравнения \f$x_{1,2} = \frac{-b \pm \sqrt{D}}{2a}\f$
  станет бесконечным (для просто огромных чисел). Поэтому делается попытка разделить всё уравнение на \f$ 2a \f$, чтобы
  уменьшить коэффициенты. Это имеет смысл, если \f$ 2a>1 \f$ (иначе они только увеличатся). И опять вызывается 
  функция count_sqrt_discriminant уже с новыми коэффициентами. При этом нужно установить точность вычисления epsilon в 
  значение "l", что соответствует наибольшей точности. Это нужно чтобы из-за точности дискриминант случайно не занулился.
  Дело в том, что этот случай возможен только при ненулевом дискриминанте, и пропорциональном изменении всех 
  коэффициентов должен остаться ненулевым.

  Если такое сокращение коэффициентов всё равно будет давать бесконечность, то это судьба - значит один из 
  корней уравнения действительно по абсолютной величине больше LDBL_MAX. Поэтому никаких дополнительных действий 
  не делаем, просто досчитываем значения по формуле.

  Делаем проверку на знак дискриминанта: ноль, положительный или отрицательный, что соответствует решениям OneDoubleRoot,
  TwoRealRoots и TwoComplexRoots соответственно. В последних двух случаях, чтобы соблюсти порядок корней (@ref EquationRoots)
  нужно учесть знак коэффициента a с помощью переменной sign_a. А в остальном просто считаем результат по формуле и 
  записываем его в roots.

  @subsection code_detailed_sqrt_discriminant Подробнее о функции sqrt_discriminant
  @subsection code_detailed_check_accuracy Подробнее парсинге числа в check_accuracy
  
  Парсинг строки accuracy в число достаточно стандартный.

  Вначале проверяется знак и сохраняется в переменную sign. Затем бежим в цикле по строке пока
  встречаются цифры, записывая результат в переменную ten_power. Переменная на каждой иттерации 
  увеличивается в 10 раз и затем к ней прибавляется следующая цифра.

  Но есть нюанс. В цикле добавлено ещё условие ten_power <= LDBL_MAX_10_EXP. LDBL_MAX_10_EXP -  это 
  максимальное целое значение для степени с основанием 10 в нормализованной форме представления числа long double.
  
  \@todo тесты на 0000 в check_accuracy.
 */