/** @mainpage Модуль Quadratic equation
  @section main_about_sec О модуле
  @subsection main_intro_sec Введение

  Этот модуль предназначен для поиска корней квадратного уравнения 
  \f[ax^2 + bx + c = 0.\f]

  В большинстве случаев (исключения описаны в разделе @ref main_without_discriminant_sec) 
  для вычисления корней используется формула \f[x_{1,2} = \frac{-b \pm \sqrt{D}}{2a},\f]
  где \f$D = b^2 - 4ac\f$ - дискриминант квадратного уравнения.

  Коэффициенты квадратного уравнения задаются числами с плавающей точкой расширенной точности 
  (точность типа long double). Следует обратить внимание, что числа в десятичной записи не всегда 
  могут быть представлены в виде чисел типа long double точно. По самим коэффициентам уравнения 
  невозможно понять, является это значение приближенным или точным. Поэтому вычисления корней 
  происходят с некоторой ошибкой.

  В большинстве случаев, эта ошибка незначительна. Однако в случае, когда значение дискриминанта 
  оказывается вблизи нуля, вклад этой ошибки может привести к значимым последствиям. Например, 
  вместо одного действительного корня, может получится два комплексных корня с ненулевой мнимой частью.
  
  Для предотвращения таких проблем, пользователи библиотеки могут задавать точность передаваемых 
  коэффициентов отдельной строковой переменной. Подробнее об этом см. на странице @ref accuracy.

  @subsection main_manual_sec Краткая инструкция

  Рекомендуемый способ использования библиотеки представлен в следующем примере.

  @code
    float a = 1.0, b = 0.02, c = 0.0001;
    EquationRoots result1 = SOLVE_EQUATION(a, b, c, "2");
    EquationRoots result2 = SOLVE_EQUATION(a, b, c);
  @endcode

  В этом примере пременные a, b и c является коэффициентами квадратного уравнения 
  \f$ax^2 + bx + c = 0\f$ (именно в таком порядке). Они могут быть произвольного числового типа 
  (в примере это типа float) и будут автоматически преобразованы в тип long double.

  Переменные result1 и result2 являются структурой EquationRoots, содержащей информацию о корнях 
  квадратного уравнения. В этой структуре есть поле @ref EquationRoots::rootsNumber, которое содержит количество 
  и тип корней, а также два поля типа long double complex root1 и root2, которые содержат значения первого и второго корня 
  квадратного уравнения.

  Макрос @ref SOLVE_EQUATION вызывает функцию вычисления корней квадратного уравнения. Причем в первом случае,
  передается информация, что наибольшая точность переданных коэффициентов составляет 2 знака после запятой.
  Во втором случае будет использоваться наибольшая точность по умолчанию. Этот пример демонстрирует
  случай, когда вычисляемое значение дискриминанта близко к нулю. В первом случае в результате получится
  один действительный корень (точнее два одинаковых корня с нулевой мнимой частью), во втором — два разных
  комплексных корня с ненулевой мнимой частью.

  Макрос @ref SOLVE_EQUATION явлется удобным способом организовать вызов функций @ref solve_equation и 
  @ref solve_equation_accur. Если макрос принимает 3 аргумента, то он вызывает функцию @ref solve_equation. 
  Если макрос принимает 4 аргумент, то он вызывает функцию @ref solve_equation_accur. Таким образом, 
  приведенный выше код будет преобразован компилятором в следующий:

  @code
    float a = 1.0, b = 0.02, c = 0.0001;
    EquationRoots result1 = solve_equation_accur(a, b, c, "2");
    EquationRoots result2 = solve_equation(a, b, c);
  @endcode

  Вызов функции solve_equation(a, b, c), эквивалентен вызову solve_equation_accur(a, b, c, NULL).
  Подробнее о использовании точности описано на странице @ref accuracy.

  @subsection main_without_discriminant_sec Случаи нахождения корней без вычисления дискриминанта

  Существует 2 случая, когда решение квадратного уравнения \f$ax^2 + bx + c = 0\f$ будет найдено без 
  вычисления дискриминанта:

  - Хотя бы один коэффициент a, b или c не является конечным числом, т.е. равен NAN, INFINITY или -INFINITY;
  - Хотя бы один коэффициент a, b или c равен 0.

  В первом случае будет получена ошибка @ref InvalidValue. Во второй случае будет 
  использованы более точные формулы для вычисления корней квадратного уравнения.

  @warning В последнем случае (нулевой коэффициент) значение точности коэффициентов квадратного уравнения (последний 
  аргумент функции @ref solve_equation_accur) будет проигнорирован, даже если оно равно "z" или "Z".

  Также см. @ref accuracy.

 */
 
/** 
  @page accuracy Понятие точности
  @section accur_about_sec Про точность
  @subsection accur_intro_sec Введение

  При расчете корней квадратного уравнения учитывается точность передаваемых коэффициентов квадратного уравнения. 
  У пользователя есть 3 споcоба задания точности:

  - в виде целого числа, означающего количество знаков после запятой (@ref accur_absolute_sec);
  - в виде буквы, означающей тип передаваемых коэффициентов (@ref accur_relative_sec);  
  - не задавать точность. В этом случае используется точность по умолчанию (@ref accur_default_sec).

  Точность задается последним четвертым аргументом функции @ref solve_equation_accur или макроса @ref SOLVE_EQUATION. 
  Тип этого аргумента - const char* (строка). При использовании функции @ref solve_equation или макроса 
  @ref SOLVE_EQUATION с тремя аргументами используется точность по умолчанию.

  Значение точности используется только когда для поиска корней квадратного уравнения необходимо вычислять дискриминант.
  Это происходит если все коэффициенты квадратного уравнения являются конечными ненулевыми числами 
  (@ref main_without_discriminant_sec). В этом случае, происходит проверка строки accuracy на корректность 
  (@ref accur_error_sec). Если строка не корректна, то будет выданна ошибка @ref InvalidValue.

  @subsection accur_absolute_sec Абсолютная точность
  Если строка, задающая точность начинается с целого числа, то это число используется в качестве значения абсолютной
  точности. В этом случае строка может начинаться с одного знака "+", "-", либо сразу с цифры. Если в строке
  присутствует дробное число в десятичной записи, то в качестве точности используется только целая часть, 
  а дробная  часть будет отброшена.
  
  Следующий код показывает корректные способы задания абсолютной точности.
  
  @code
    result = SOLVE_EQUATION(a, b, c, "2"); // значение абсолютной точности равно 2
    result = solve_equation_accur(a, b, c, "+13"); // значение абсолютной точности равно 13
    result = SOLVE_EQUATION(a, b, c, "0"); // значение абсолютной точности равно 0
    result = solve_equation_accur(a, b, c, "-1054"); // значение абсолютной точности равно -1504
  @endcode

  Если значение абсолютной точности равно n, то считается, что максимальная точность коэффициентов квадратного уравнения 
  равна n знакам после запятой. Для абсолютной точности равной нулю, считается, что все коэффициенты квадратного уравнения
   - целые числа. Если значение абсолютной точности отрицательно и равно -n , то считается, что каждый коэффициент целое 
  число и делится без остатка на \f$10^n\f$, т.е. как минимум n последних цифр в десятичной записи являются нулями.

  @warning
  - Значение абсолютной точности большее LDBL_MAX_10_EXP эквивалентно заданию относительной точности со значением "l". 
  - Значение абсолютной точности меньшее -LDBL_MAX_10_EXP эквивалентно заданию относительной точности со значением "z".

  Значение абсолютной точности используется для проверки значения дискриминанта. Проверяется следующее условие
  \f[|D| < 10 ^ {-2 \cdot accuracy},\f] где \f$D\f$ - дискриминант, а \f$accuracy\f$ - значение абсолютной точности.
  Если условие выполнено, то значение дискриминанта принимается нулевым и результатом решения уравнения является 
  @ref OneDoubleRoot. В ином случае, используется вычисленное значение дискриминанта и результатом 
  решения уравнения является @ref TwoRealRoots или @ref TwoComplexRoots.

  @subsection accur_relative_sec Относительная точность

  Если не известно значение абсолютной точности коэффициентов квадратного уравнения, то рекомендуется задать относительную точность.

  Для универсальности все коэффициенты a, b, c квадратного уравнения автоматически конвертируются в тип long double, 
  а информацию об их исходном типе следует передавать через относительную точность.

  Ниже перечислены корректные значения относительной точности.

  | Значение      | Описание                         |
  |---------------|----------------------------------|
  | "i" or "I"    | целочисленные коэффициенты       |
  | "f" or "F"    | коэффициенты типа float          |
  | "d" or "D"    | коэффициенты типа double         |
  | "l" or "L"    | коэффициенты типа long double    |
  | "z" or "Z"    | приравнять дискриминант к нулю   |

  @warning
  Значение точности "z" и "Z" вряд ли могут быть использованы для решения уравнения, т.к. императивно устанавливает
  результат @ref OneDoubleRoot, даже если это не так. В коде они используются для задания экстремально низких значений 
  абсолютной точности меньших -LDBL_MAX_10_EXP. Однако значения "z" и "Z" могут быть использованы для тестирования.

  Значения "i" и "I" равносильны заданию абсолютной точности равной нулю. Т.е. следующий выражения эквивалентны:

  @code
    result = SOLVE_EQUATION(a, b, c, "0");
    result = SOLVE_EQUATION(a, b, c, "i");
    result = solve_equation_accur(a, b, c, "I");
  @endcode  

  @warning
  Если коэффициенты имеют разные типы, то нужно передавать тип коэффициента с наибольшей точностью. Т.е. для 
  трех коэффициентов типа int, float и double следует использовать точность "d".

  @subsection accur_default_sec Точность по умолчанию

  @warning
  По умолчанию задана точность "l".

  Задать точность по умолчанию можно следующим образом:
  - использовать функцию @ref solve_equation;
  - использовать макрос @ref SOLVE_EQUATION с тремя аргументами;
  - передать NULL четвертым аргументом в функцию @ref solve_equation_accur или макрос @ref SOLVE_EQUATION;
  - передать пустую строку четвертым аргументом в функцию @ref solve_equation_accur или макрос @ref SOLVE_EQUATION.

  Следующие выражения задают точность по умолчанию:

  @code
    result = SOLVE_EQUATION(a, b, c);
    result = SOLVE_EQUATION(a, b, c, "");
    result = SOLVE_EQUATION(a, b, c, NULL);
    result = solve_equation_accur(a, b, c);
    result = solve_equation_accur(a, b, c, "");
    result = solve_equation_accur(a, b, c, NULL);
  @endcode 

  @subsection accur_error_sec Ошибки в задании точности

  Аргумент accuracy задан корректно, если выполняется хотя бы один из следующих пунктов:
  - равен NULL или пустой строке "";
  - начинается с символа цифры "0" до "9";
  - начинается с символа "-" или "+", после которого обязательно следуют символы цифр "0" до "9";
  - начинается с одного из символов "i", "I", "f", "F", "d", "D", "l", "L", "z", "Z".

  Первый пункт используется для задания точности по умолчанию (@ref accur_default_sec). Второй и третий пункты 
  используются для задания абсолютной точности (@ref accur_absolute_sec). Последний пункт используется для задания 
  относительной точности (@ref accur_relative_sec).

  Во всех остальных случаях функция возвращает ошибку @ref InvalidValue в случае вычисления дискриминанта.
  Если дискриминант не вычисляется (@ref main_without_discriminant_sec), значение точности не используется 
  и ошибка не возвращается, даже при неверном задании аргумента accuracy.

  При задании относительной точности используется используется только первый символ строки. При задании абсолютной 
  точности используются только символы преобразуемые в целое число, меньшие по абсолютному значению LDBL_MAX_10_EXP. 
  Оставшиеся символы строки, если они присутствуют, будут проигнорированы.

  @warning
  Дополнительные символы строки, не приводят к возврату ошибки @ref InvalidValue, но могут 
  привести к неверным результатам, т.к. будут интерпретированы иначе, чем предполагал пользователь.

  Ниже приведены примеры неправильного задания точности, но не вызовут ошибки @ref InvalidValue :

  @code
    int a = 1000;
    float b = -0.01;
    double c = 0.000000024;
    EquationRoots result;
    result = SOLVE_EQUATION(a, b, c, "ifd");          // будет задана точность "i", т.е. абсолютная точность равная нулю
    result = SOLVE_EQUATION(a, b, c, "i2f9d");        // будет задана точность "i", т.е. абсолютная точность равная нулю
    result = SOLVE_EQUATION(a, b, c, "2d");           // будет задана точность "2"
    result = SOLVE_EQUATION(a, b, c, "0.000000024");  // будет задана точность "0"
    result = SOLVE_EQUATION(a, b, c, "2.67");         // будет задана точность "2"
    result = SOLVE_EQUATION(a, b, c, "1e+3");         // будет задана точность "1"
    result = SOLVE_EQUATION(a, b, c, "-9");           // будет задана точность "-9"
  @endcode

  Во всех этих примерах будет ошибочный результат @ref OneDoubleRoot с root1 = root2 = 5e-6 + 0 * I, т.к. 
  в итоге будет задано слишком низкое значение точности. Из-за этого значение дискриминанта будет принято равным нулю.
  Правильно в этом случае будет задать точность "9" или "d" - наибольшую точность среди коэффициентов
  (правильный результат будет @ref TwoRealRoots с root1 = 4e-6 + 0 * I и root2 = 6e-6 + 0 * I).

  Можно ошибиться и задав избыточную точность. Вот код демонстрирующий это:

  @code
    float a = 1e20;
    float b = 2e18;
    float c = 1e16;
    EquationRoots result;
    result = SOLVE_EQUATION(a, b, c, "i");        // будет задана точность "i", т.е. абсолютная точность равная нулю
    result = SOLVE_EQUATION(a, b, c, "d");        // будет задана точность "d"
    result = SOLVE_EQUATION(a, b, c, "16");       // пропущен знак минус
  @endcode

  Во всех этих примерах будет ошибочный результат @ref TwoComplexRoots с root1 = -0.01 + 3e-6 * I и 
   root2 = -0.01 + 3e-6 * I, т.к. в итоге будет задано слишком высокое значение точности. Из-за этого значение 
  дискриминанта не будет принято равным нулю. Правильно в этом случае будет задать точность "-16" или "d" - наибольшую 
  точность среди коэффициентов (правильный результат будет @ref OneDoubleRoot : с root1 = root2 = -0,01 + 0 * I).

*/
